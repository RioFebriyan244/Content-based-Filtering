# -*- coding: utf-8 -*-
"""Untitled15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FnU_P07-JcLMAzuvjmzu3gaSp0ABqv0H
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras import Input, Model
from tensorflow.keras.layers import Dense
from sklearn.decomposition import PCA
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import OneHotEncoder, MinMaxScaler
from sklearn.metrics.pairwise import cosine_similarity
from scipy.sparse import hstack

"""
##Load Data
### Tahap 1: Tahapan ini adalah langkah awal, yaitu mengambil data dari sumbernya dan memasukkannya ke dalam program Python"""

df = pd.read_csv("products.csv")

"""####Pada Tahap df.info() dataset lengkap: Tidak ada nilai kosong, sehingga tidak perlu pembersihan data terkait missing values."""

df.info()

"""#### Pada tahap df.head() menampilkan data 5 data pertama dari dataset , susunan ini masih belum sesuai dengan apa yang di harapkan"""

df.head()

"""##Data Cleaning
### Tahap 2 :  Memastikan data bersih dan konsisten agar tidak memengaruhi hasil

###Mengecek apakah data ada yang kosong atau tidak,
####dengan  hasil dari pengecekan di ketahui bahwa dataset tidak ada yang kosong
"""

df.isnull().sum()

"""###Mengecek apakah data ada yang duplikat atau tidak,
####dan dari hasil analisa tidak ada data yang duplikat
"""

df.duplicated().sum()

"""##Preprocessing Data
### Tahap 3: Menyiapkan data agar siap digunakan oleh model machine learning

###Mengubah data teks dan kategorikal menjadi bentuk numerik.
"""

tfidf = TfidfVectorizer(stop_words='english')
title_matrix = tfidf.fit_transform(df['Title'])

encoder = OneHotEncoder()
categorical_matrix = encoder.fit_transform(df[['Size', 'Gender']])

scaler = MinMaxScaler()
numeric_matrix = scaler.fit_transform(df[['Price', 'Rating', 'Colors']])

"""###Gabungkan semua fitur"""

feature_matrix = hstack([title_matrix, categorical_matrix, numeric_matrix])

"""###Membuat label dummy (contoh: kategori Gender sebagai target)"""

y = df['Gender']

"""##Train-Test Split
###Tahap 4: Membagi model dengan sebagian data (training) dan mengujinya dengan data lain (testing) untuk mengevaluasi performa
"""

X_train, X_test, y_train, y_test = train_test_split(feature_matrix, y, test_size=0.2, random_state=42)

"""##Membangun Model TensorFlow untuk Klasifikasi
### Tahap 5: Menggunakan TensorFlow (keras) untuk membuat model klasifikasi, misalnya mengklasifikasikan produk ke dalam kategori fashion

###Encode target label ke integer
"""

label_map = {label: idx for idx, label in enumerate(y.unique())}
y_train_encoded = np.array([label_map[val] for val in y_train])
y_test_encoded = np.array([label_map[val] for val in y_test])

"""###Menggunakan TensorFlow untuk melatih model prediksi Gender"""

input_layer = Input(shape=(X_train.shape[1],))
x = Dense(128, activation='relu')(input_layer)
x = Dense(64, activation='relu')(x)
output_layer = Dense(len(y.unique()), activation='softmax')(x)

model = Model(inputs=input_layer, outputs=output_layer)

model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

"""###Melatih Model
####Hasil dari models menun jukan hasil Training: 1.0306 → 0.0012 , Validasi: 0.7369 → 0.0018 Model sangat baik dalam mempelajari fitur produk untuk klasifikasi Gender
"""

history = model.fit(X_train.toarray(), y_train_encoded, epochs=10, batch_size=32, verbose=1, validation_data=(X_test.toarray(), y_test_encoded))

"""###Evaluate model
####Dengan Akurasi yang di peroleh 100% Model mampu mempelajari data dengan sangat baik dan mencapai performa maksimal tanpa overfitting


"""

loss, accuracy = model.evaluate(X_test.toarray(), y_test_encoded)
print("Akurasi Model: {:.2f}%".format(accuracy * 100))

"""###Classification report
####Precision, Recall, dan F1-Score untuk setiap kelas = 1.00 (maksimal).Artinya, tidak ada kesalahan klasifikasi pada data uji.
"""

y_pred = model.predict(X_test.toarray())
y_pred_labels = np.argmax(y_pred, axis=1)
print(classification_report(y_test_encoded, y_pred_labels))

"""##Visualisasi Embedding Produk
### Tahap 6: Embedding adalah representasi vektor dari kata atau teks. Visualisasi ini digunakan untuk melihat kemiripan produk dalam ruang vektor
####dari hasil Embedding dapat di simpulkan embedding produk berhasil merepresentasikan perbedaan fitur secara signifikan
"""

embedding_model = tf.keras.Model(inputs=model.input, outputs=model.layers[-2].output)
embeddings = embedding_model.predict(feature_matrix.toarray())

pca = PCA(n_components=2)
reduced_embeddings = pca.fit_transform(embeddings)

plt.figure(figsize=(10,6))
plt.scatter(reduced_embeddings[:,0], reduced_embeddings[:,1], alpha=0.5)
plt.title('Visualisasi Produk Berdasarkan Embedding')
plt.xlabel('PCA 1')
plt.ylabel('PCA 2')
plt.grid(True)
plt.show()

"""##Visualisasi Hasil Pelatihan
###Tahap 7 : Mevisualisasikan hasil model dengan menampilkan grafik Accuracy & Loss
####Training dan validasi akurasi = 100% mulai epoch ke-2.Baik loss training maupun validasi cepat turun hingga ~0 pada epoch ke-3. Tidak ada overfitting yang terlihat dari perbedaan antara loss training dan validasi → keduanya sangat seragam.
"""

plt.figure(figsize=(14, 5))

# Grafik Akurasi
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Akurasi Training')
plt.plot(history.history['val_accuracy'], label='Akurasi Validasi')
plt.title('Akurasi Selama Training')
plt.xlabel('Epoch')
plt.ylabel('Akurasi')
plt.legend()
plt.grid(True)

# Grafik Loss
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Loss Training')
plt.plot(history.history['val_loss'], label='Loss Validasi')
plt.title('Loss Selama Training')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

"""##Content-Based Filtering
###Tahap 8 : Sistem Rekomendasi Content-Based Filtering berdasarkan Rating Menghitung cosine similarity antar produk

###Fungsi rekomendasi berdasarkan rating tinggi dan kesamaan fitur
"""

def recommend_by_rating(product_index, top_n=5):
    similarity_matrix = cosine_similarity(feature_matrix)
    similarity_scores = list(enumerate(similarity_matrix[product_index]))
    similarity_scores = sorted(similarity_scores, key=lambda x: x[1], reverse=True)
    similar_indices = [i for i, score in similarity_scores[1:] if df.iloc[i]['Rating'] >= df.iloc[product_index]['Rating']]
    return df.iloc[similar_indices[:top_n]][['Title', 'Price', 'Rating']]

"""###Metrik NDCG@K akan mengukur seberapa baik sistem rekomendasimu dalam memberikan saran item yang relevan kepada pengguna
#### Skor 0.988 menunjukkan rekomendasi kamu sangat baik — hampir semua item yang direkomendasikan di posisi 1–5 sesuai dengan relevansi yang diharapkan.
"""

from sklearn.metrics import ndcg_score

def evaluate_recommendation(product_index, k=5):
    recommended = recommend_by_rating(product_index, top_n=k)
    recommended_indices = recommended.index.tolist()


    relevant_items = df[df['Rating'] >= 4.0].index.tolist()

    hits = [1 if idx in relevant_items else 0 for idx in recommended_indices]


    # NDCG@K
    relevance_scores = [df.loc[idx, 'Rating'] if idx in relevant_items else 0 for idx in recommended_indices]
    ideal = sorted(relevance_scores, reverse=True)
    ndcg = ndcg_score([ideal], [relevance_scores])

    return {
        "NDCG@{}".format(k): round(ndcg, 3)
    }

print(evaluate_recommendation(0, k=5))

"""###Contoh penggunaan rekomendasi berdasarkan rating
#### Semua produk memiliki rating ≥ produk input Rekomendasi ini mengikuti kriteria: "rating setara atau lebih tinggi".Rating semua produk berada di atas 4.1, dengan tertinggi 4.4. hasil dari content-based filtering Semua item bertipe “T-shirt” → artinya fitur seperti title/kategori dipakai dalam pemodelan.Model menggunakan filter berdasarkan konten + threshold rating untuk menampilkan item serupa.
"""

print("\nRekomendasi produk mirip dengan rating setara atau lebih tinggi:")
print(recommend_by_rating(0))